fn begin(name) {
    "// BEGIN " ++ name ++ NL
}

fn end(name) {
    "// END " ++ name ++ NL(2)
}

"// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!!!" ++ NL(2);

"namespace " ++ model.name.join(".") ++ " {" ++ NL(2);

begin("INCLUDES");
for imp in model.imports {
    "include <" ++ imp.path.join("/") ++ ">" ++ NL
}

end("INCLUDES");

-(NL);

begin("ENUMS");

for enum in model.enums {
    "enum " ++ enum.first ++ " {";
        let prefix = "";
        for enum_value in enum.second.values {
            let name = enum_value.first;
            let enum_value = enum_value.second;
            if is_some(enum_value.value) {
                prefix ++ NL ++ IND ++ name ++ " = " ++ unwrap(enum_value.value);
            } else {
                prefix ++ NL ++ IND ++ name;
            }
            prefix = ","
        }
    NL ++ "};" ++ NL(2);
}

end("ENUMS");

-(NL);

begin("DATATYPES");

for data_type in model.data_types {
    "struct " ++ data_type.first ++ " {" ++ NL;
        for property in data_type.second.properties {
            IND ++ property.second.typ.join("::") ++ " " ++ property.first ++ ";" ++ NL;
        }
    "};" ++ NL(2);
}
end("DATATYPES");

-(NL);

begin("SERVICES");
for service in model.services {
    "class " ++ service.first ++ " {" ++ NL;
    for function in service.second.functions {
        IND ++ function.second.return_type.unwrap_or("void") ++
        " " ++ function.first ++ "(";

        let prefix = "";
        for argument in function.second.arguments {
            prefix ++ argument.second.typ.join("::") ++ " " ++ argument.first;
            prefix = ", ";
        }

        ") = 0;" ++ NL;
    }
    "};" ++ NL(2);
}
end("SERVICES");

"}" ++ NL
