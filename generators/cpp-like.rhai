fn begin(name) {
    "// BEGIN " ++ name ++ NL
}

fn end(name) {
    "// END " ++ name ++ NL(2)
}

"// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT!!!" ++ NL(2);

"namespace " ++ module.name.join(".") ++ " {" ++ NL(2);

begin("INCLUDES");
for imp in module.imports {
    "include <" ++ imp.path.join("/") ++ ">" ++ NL
}

end("INCLUDES");

-(NL);

begin("ENUMS");

for enum in module.enums {
    "enum " ++ enum.first ++ " {";
        let prefix = "";
        for enum_value in enum.second.values {
            let name = enum_value.first;
            let enum_value = enum_value.second;
            if is_some(enum_value.value) {
                prefix ++ NL ++ IND ++ name ++ " = " ++ unwrap(enum_value.value);
            } else {
                prefix ++ NL ++ IND ++ name;
            }
            prefix = ","
        }
    NL ++ "};" ++ NL(2);
}

end("ENUMS");

-(NL);

begin("DATATYPES");

for data_type in module.data_types {
    "struct " ++ data_type.first ++ " {" ++ NL;
        for property in data_type.second.properties {
            if property.second.is_list {
                let count = property.second.count;
                if is_some(count) {
                    let count = unwrap(count);
                    IND ++ property.second.typ.join("::") ++ " " ++ property.first ++ "[" ++ count ++ "];" ++ NL;
                } else {
                    IND ++ property.second.typ.join("::") ++ " " ++ property.first ++ "[]" ++ ";" ++ NL;
                }
            } else {
                IND ++ property.second.typ.join("::") ++ " " ++ property.first ++ ";" ++ NL;
            }
        }
    "};" ++ NL(2);
}
end("DATATYPES");

-(NL);

begin("SERVICES");
for service in module.services {
    "class " ++ service.first ++ " {" ++ NL;
    for function in service.second.functions {
        if is_some(function.second.return_type) {
            let return_type = unwrap(function.second.return_type);
            if return_type.is_list {
                prefix ++ return_type.typ.join("::") ++ "[]";
            } else {
                IND ++ return_type.typ.join("::");
            }
        } else {
            IND ++ "void";
        }

        " " ++ function.first ++ "(";

        let prefix = "";
        for argument in function.second.arguments {
            if argument.second.is_list {
                let count = argument.second.count;
                if is_some(count) {
                    let count = unwrap(count);
                    prefix ++ argument.second.typ.join("::") ++ " " ++ argument.first ++ "[" ++ count ++ "]";
                } else {
                    prefix ++ argument.second.typ.join("::") ++ " " ++ argument.first ++ "[]";
                }
            } else {
                prefix ++ argument.second.typ.join("::") ++ " " ++ argument.first;
            }
            prefix = ", ";
        }

        ") = 0;" ++ NL;
    }
    "};" ++ NL(2);
}
end("SERVICES");

"}" ++ NL
